---
layout:     post
title:      重学git
category: 博客
tags: 
description: git
---
#基础
##撤销
###修改最后一次提交

	git commit --amend
	
此操作可以修改上一次commit的内容

###取消暂存的文件

	git reset HEAD filename
	
任何已经提交到 Git 的都可以被恢复。即便在已经删除的分支中的提交，或者用 --amend 重新改写的提交，都可以被恢复

###取消当前修改

	git checkout -- file

这个命令有点危险，修改全没了，不要轻易用

##远程
###抓取

	git fetch origin

会抓取从你上次克隆以来别人上传到此远程仓库中的所有更新（或是上次 fetch 以来别人提交的更新）。fetch 命令只是将远端的数据拉到本地仓库，并不自动合并到当前工作分支。

	git remote show origin //查看远程分支以及详细情况
	
##分支
`分支其实就是从某个提交对象往回看的历史`

可以想象成一个逻辑框图或者树结构……

`git checkout master`它把 HEAD 指针移回到 master 分支，并把工作目录中的文件换成了 master 分支所指向的快照内容。

新建一个分支就是向一个文件写入 41 个字节（外加一个换行符）

###合并
如果顺着一个分支走下去可以到达另一个分支的话，那么 Git 在合并两者时，只会简单地把指针右移，因为这种单线的历史分支不存在任何需要解决的分歧，所以这种合并过程可以称为快进（Fast forward）

当你在使用分支及合并的时候，一切都是在你自己的 Git 仓库中进行的 — 完全不涉及与服务器的交互

###远程分支
远程分支就像是书签，提醒着你上次连接远程仓库时上面各分支的位置

在 fetch 操作下载好新的远程分支之后，你仍然无法在本地编辑该远程仓库中的分支，拥有的只是一个无法移动的指针而已。

接下来需要用：

	git checkout -b local_branch origin/remote_branch
	
	git merge origin/remote_branch   或者合并到当前分支
	
###删除远程分支

	git push origin :remote_name
	这个`冒号`那可是相当的重要啊
	
###rebase

	git checkout branch
	git rebase master
	
它的原理是回到两个分支最近的共同祖先，根据当前分支（也就是要进行衍合的分支）后续的历次提交对象，生成一系列文件补丁，然后以基底分支（也就是主干分支master）最后一个提交对象为新的出发点，逐个应用之前准备好的补丁文件，最后会生成一个新的合并提交对象，从而改写branch的提交历史，使它成为master分支的直接下游

一旦分支中的提交对象发布到公共仓库，就千万不要对该分支进行衍合操作。

##提交
*	不要在更新中提交多余的白字符，可以用`git diff --check`检查
*	每次提交限定于完成一次逻辑功能，适当分解为多次小更新

在推送数据之前，先确认下要并进来的数据究竟是什么，于是运行 git log 查看：

	git fetch origin
	
	git log --no-merges origin/master ^your_branch

##暂存
暂存：

	git stash
	git stash apply  //暂存后切回来重新应用
	git stash list   //查看暂存内容
	git stash apply --index   //对文件的变更被重新应用，但是被暂存的文件没有重新被暂存
	
apply 选项只尝试应用储藏的工作——储藏的内容仍然在栈上。

	git stash drop //移除
	
取消暂存：

	git stash unapply //不提供，但是可以配置在git alias里面
	或者
	git stash show -p | git apply -R
	
从暂存中创建分支：

	git stash branch

创建一个新的分支，检出你储藏工作时的所处的提交，重新应用你的工作，如果成功，将会丢弃储藏

##修改提交
修改最近`四次`的提交，不是3哦~

	git rebase -i HEAD~3
	
HEAD~3..HEAD范围内的`每一次提交都会被重写`，`无论你是否修改说明`。但是`已经推送到服务器的提交最好不要修改`，这回使得其它开发者混乱~

交互式的rebase给了你一个即将运行的脚本。它会从你在命令行上指明的提交开始(HEAD~3)然后自上至下重播每次提交里引入的变更。

	git commit --amend   //确定要修改啥……
	
	git rebase --continue   //修改之后把不要修改的补上？大概这么理解吧~
	
将这三个提交合并为单一提交:

	squash
	
拆分提交：
拆分提交就是撤销一次提交，然后多次部分地暂存或提交直到结束

>>一定要确认所有的修改不包含已经push到服务器共享的commit，否则会造成紊乱……

###清理历史提交
这个比较x，比如不小心提交了安装包，二进制文件等很大的文件，那么就应该应用这个命令了。

	git filter-branch --tree-filter 'rm -f passwords.txt' HEAD
	
	--tree-filter选项会在每次检出项目时先执行指定的命令然后重新提交结果。在这个例子中，你会在所有快照中删除一个名叫 password.txt 的文件，无论它是否存在。
	
你可以观察到 Git 重写目录树并且提交，然后将分支指针移到末尾。一个比较好的办法是在一个测试分支上做这些然后在你确定产物真的是你所要的之后，再 hard-reset 你的主分支。要在你所有的分支上运行filter-branch的话，你可以传递一个--all给命令。

###将一个子目录设置为新的根目录

	git filter-branch --subdirectory-filter folder HEAD
	
现在folder就是根目录了，git会自动删除不受影响的提交……

