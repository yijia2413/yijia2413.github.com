---
layout:     post
title:      重学git
category: 博客
tags: 
description: git
---
#基础
##撤销
###修改最后一次提交

	git commit --amend
	
此操作可以修改上一次commit的内容

###取消暂存的文件

	git reset HEAD filename
	
任何已经提交到 Git 的都可以被恢复。即便在已经删除的分支中的提交，或者用 --amend 重新改写的提交，都可以被恢复

###取消当前修改

	git checkout -- file

这个命令有点危险，修改全没了，不要轻易用

##远程
###抓取

	git fetch origin

会抓取从你上次克隆以来别人上传到此远程仓库中的所有更新（或是上次 fetch 以来别人提交的更新）。fetch 命令只是将远端的数据拉到本地仓库，并不自动合并到当前工作分支。

	git remote show origin //查看远程分支以及详细情况
	
##分支
`分支其实就是从某个提交对象往回看的历史`

可以想象成一个逻辑框图或者树结构……

`git checkout master`它把 HEAD 指针移回到 master 分支，并把工作目录中的文件换成了 master 分支所指向的快照内容。

新建一个分支就是向一个文件写入 41 个字节（外加一个换行符）

###合并
如果顺着一个分支走下去可以到达另一个分支的话，那么 Git 在合并两者时，只会简单地把指针右移，因为这种单线的历史分支不存在任何需要解决的分歧，所以这种合并过程可以称为快进（Fast forward）

当你在使用分支及合并的时候，一切都是在你自己的 Git 仓库中进行的 — 完全不涉及与服务器的交互

###远程分支
远程分支就像是书签，提醒着你上次连接远程仓库时上面各分支的位置

在 fetch 操作下载好新的远程分支之后，你仍然无法在本地编辑该远程仓库中的分支，拥有的只是一个无法移动的指针而已。

接下来需要用：

	git checkout -b local_branch origin/remote_branch
	
	git merge origin/remote_branch   或者合并到当前分支
	
###删除远程分支

	git push origin :remote_name
	这个`冒号`那可是相当的重要啊
	
###rebase

	git checkout branch
	git rebase master
	
它的原理是回到两个分支最近的共同祖先，根据当前分支（也就是要进行衍合的分支）后续的历次提交对象，生成一系列文件补丁，然后以基底分支（也就是主干分支master）最后一个提交对象为新的出发点，逐个应用之前准备好的补丁文件，最后会生成一个新的合并提交对象，从而改写branch的提交历史，使它成为master分支的直接下游

一旦分支中的提交对象发布到公共仓库，就千万不要对该分支进行衍合操作。

##提交
*	不要在更新中提交多余的白字符，可以用`git diff --check`检查
*	每次提交限定于完成一次逻辑功能，适当分解为多次小更新

在推送数据之前，先确认下要并进来的数据究竟是什么，于是运行 git log 查看：

	git fetch origin
	
	git log --no-merges origin/master ^your_branch

 test