---
layout: post
title: Homework1@jsk
category: jsk
tags: 
  - 习题
imagefeature: null
mathjax: false
chart: false
comments: true
featured: false
published: true
---
> 请上网了解”三分查找”的含义，并且举一个例子应用算法并做描述	

答：在二分查找的基础上，在右区间（或左区间）再进行一次二分，这样的查找算法称为三分查找，也就是三分法。三分查找通常用来迅速确定最值。

![img](/images/post/jsk/sanfen.png)

如上图所示，最顶端为需要查找的点，做如下操作，即可得到答案：
先取 [L,R] 的中点 mid，再取 [mid,R]的中点 mmid，通过比较 f(mid) 与 f(mmid) 的大小来缩小范围。当最后 L=R-1 时，再比较下这两个点的值，我们就找到了答案。
伪代码如下：

	int fun(int l,int r)
	{
    	while(l < r-1)
    	{
        	int mid  = (l+r)/2;
        	int mmid = (mid+r)/2;
        	if( f(mid) > f(mmid) )
            	r = mmid;
        	else
            	l = mid;
    	}
    	return f(l) > f(r) ? l : r;
	}


其中f(x)代表要查找当前x的值


>	请上网了解欧氏距离与曼哈顿距离的概念，并在下面做出陈述

答：__欧氏距离：__指在m维空间中两个点之间的真实距离，或者向量的自然长度（即该点到原点的距离）。在二维和三维空间中的欧氏距离就是两点之间的实际距离。

__曼哈顿距离：__曼哈顿距离的正式意义为L1-距离或城市区块距离，也就是在欧几里德空间的固定直角坐标系上两点所形成的线段对轴产生的投影的距离总和。

曼哈顿距离示意图在早期的计算机图形学中，屏幕是由像素构成，是整数，点的坐标也一般是整数，原因是浮点运算很昂贵，很慢而且有误差，如果直接使用AB的距离，则必须要进行浮点运算，如果使用AC和CB，则只要计算加减法即可，这就大大提高了运算速度，而且不管累计运算多少次，都不会有误差。

欧氏距离(欧几里德距离)：在二维和三维空间中的欧式距离的就是两点之间的距离，二维的公式是三维的公式是推广到n维空间，欧式距离的公式是 这里i=1,2...n,表示第一个点的第i维坐标, 表示第二个点的第i维坐标。


*	字母 H 的 ASCII 码是__72__ 
*	数字 9 的 ASCII码是__57__
*	十进制数字734的二进制表示是__1011011110__
*	二进制数字 1000 + 1010101010 的结果的十进制表示是__690__
*	请写出纯红色的十六进制RGB色值编码#`FF0000`

> 请简述身份证最后一个校验位的编码方式：

答：校验位是根据前面十七位数字码，按照ISO 7064:1983.MOD 11-2校验码计算出来的检验码。

计算公式：∑(a[i]×W[i])(mod 11)

i表示号码字符从右至左包括校验码在内的位置序号, a[i]表示第i位置上的号码字符值, W[i]计算公式为：2^(i-1) mod (11)， 表示第i位上的加权因子。

最后，得出∑(a[i]×W[i])(mod 11)的值， 0 1 2 3 4 5 6 7 8 9 10， 查校验码字符表，得到的就是最后一位的值。


> 请上网了解程序语言，并对以下程序语言进行分类：
	
	Python(解释型)
	PHP(解释型)			解释型语言
	C(编译型)			
	C++(编译型)			编译型语言
	Ruby(解释型)
	
> 请用除了C、C++、Java、Python、PHP、Ruby的任意三种程序语言
写一个a+b+c

__NodeJs__

	process.stdin.resume();
	process.stdin.setEncoding("utf8");
	process.stdin.on("data", function(chunk) {
    	var datas = chunk.trim().split("\n");
    	for(var i = 0; i < datas.length; i++) {
        	var abc = datas[i].trim().split(" ");
        	var a = parseInt(abc[0]);
        	var b = parseInt(abc[1]);
	    	var c = parseInt(abc[2]);
    	    console.log(a + b + c);
    	}
	});
	
	
__Go__

	package main

	import "fmt"

	func add(x int, y int, z int) int {
		return x + y + z
	}

	func main() {
		var a int
		var b int
		var c int
		fmt.Scanf("%d%d%d",&a,&b,&c)
		fmt.Println(add(a, b, c))
	}
	
	
__lua__

	local read, write = io.read, io.write
	local num, nl = '*n', '\n'

	local a = read(num)
	local b = read(num)
	local c = read(num)
	
	write(a+b+c, '\n')



> 请列举两个人工智能场景并试着给出你觉得这两个人工智能场景的共同点：

1.智能家居机器人

2.google无人驾驶汽车

共同点：能对当前环境因素进行简单的“学习”并作出相应的”反应”， 均利用了一些机器学习的模型。

未来的人工智能，应该就是公元前狩猎为生的人们，看到今天无人机时候产生的感觉，“吓尿了”



> 请上网了解流媒体的概念并写下你的理解：

`流媒体`：所谓流媒体是指采用流式传输的方式在Internet播放的媒体格式。 流媒体又叫流式媒体，它是指商家用一个视频传送服务器把节目当成数据包发出，传送到网络上。用户通过解压设备对这些数据进行解压后，节目就会像发送前那样显示出来。

“流”媒体的“流”指的是这种媒体的传输方式（流的方式），而并不是指媒体本身。

流媒体格式有很多，如：声音流、视频流、文本流、图像流、动画流

> 请上网了解“前向误差”和“后向误差”的概念，并写下你的理解:

`向后误差`分析是威尔金森20世纪60年代初在研究矩阵计算的误差时作了系统分析而提出的，目前是计算机上各种数值计算最常用的误差分析手段。他是一种先验性估计。

假设要用数值算法解决的问题是用函数f将数据x映射到解y，通常算法的结果y* 会与“真”解y有一定的偏差。误差的来源主要有舍入误差、截断误差以及数据误差。算法的前向误差是结果与真解之间的差别，在这里是Δy = y* − y。后向误差是满足f(x + Δx) = y* 的最小Δx，也就是说后向误差说明算法的所解决的问题。前向误差和后向误差通过条件数发生关系：前向误差的幅度最多是条件数乘以后向误差的幅度。

如果对于任意的输入x来说后向误差都很小，那么算法就是后向稳定的。

通常数值稳定性的定义是使用一个包括了前向误差与后向误差的更加宽泛的概念，称为混合稳定性。按照这个概念，如果一个算法是稳定的，那么存在Δx使得Δx与f(x + Δx) − y* 都很小。因此，后向稳定算法永远是稳定的。

如果算法的前向误差除以条件数得到的结果很小，那么这个算法就是前向稳定的。这就意味着如果一个算法的前向误差与后向稳定算法的误差幅度类似那么就是前向稳定的。

> 请陈述一个你生活中人机不友好的情况：

公司的电视机遥控器按钮小，反应慢，输入简直掉渣……

系统精简了太多的东西，差点连浏览器都装不上，相当的人机不友好……


> 请综合描述“软件工程”是做什么的？具体会做什么？

__软件工程__是研究和应用如何以系统性的、规范化的、可定量的过程化方法去开发和维护软件，以及如何把经过时间考验而证明正确的管理技术和当前能够得到的最好的技术方法结合起来。

软件工程是：1.将系统化的、严格约束的、可量化的方法应用于软件的开发、运行和维护，即将工程化应用于软件；2.在1中所述方法的研究

具体：一套完整的软件需求分析、软件开发流程、软件开发规范、软件运行维护规范流程等，也就是我们所说的“软件工程化”。


> 请简述一个你觉得未来网络中会有巨大意义的网络应用：

我感觉，未来巨大意义的网络应用应该具备__所见即所得__的功能.

不是说，这种应用像淘宝，看到的东西，买下来也差不多，而应该是一种量体裁衣式的东西。简单来说，比如你看中一件衣服，通过该应用，就能切身感觉你正在试穿这件衣服，而不是去比较衣服的size，要有一种真正的__身临其境__的感觉。

比如说，google earth + 裸眼3D + touch feel, 不用出门，身临其境，不是__"意淫"__, 而是切身感受，触觉上的感受。
     